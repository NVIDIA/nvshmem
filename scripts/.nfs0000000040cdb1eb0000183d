#!/bin/bash

# Script to delete files and directories listed in CPACK_SOURCE_IGNORE_FILES
# This script dynamically parses the CMakeLists.txt file to get the ignore list

# Default NVSHMEM directory (current directory)
NVSHMEM_DIR="."

# Default branch name
BRANCH_NAME="github_main_staging"

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --nvshmem-dir)
            NVSHMEM_DIR="$2"
            shift 2
            ;;
        --branch)
            BRANCH_NAME="$2"
            shift 2
            ;;
        --force)
            FORCE_MODE=true
            shift
            ;;
        --test-parse-ignore)
            TEST_PARSE_IGNORE=true
            shift
            ;;
        --test-is-protected)
            TEST_IS_PROTECTED="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [--nvshmem-dir DIR] [--branch BRANCH] [--force]"
            echo "  --nvshmem-dir DIR         Set the NVSHMEM source directory (default: current directory)"
            echo "  --branch BRANCH           Set the target branch name (default: github_main_staging)"
            echo "  --force                   Run without confirmation prompt"
            echo "  --test-parse-ignore       Test parse_ignore_files function and exit"
            echo "  --test-is-protected FILE  Test is_protected function on FILE and exit"
            echo "  -h, --help                Show this help message"
            echo ""
            echo "Supported branch types:"
            echo "  github_main_staging        - Main staging branch (default)"
            echo "  github_devel_staging       - Development staging branch"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Convert to absolute path
NVSHMEM_DIR=$(realpath "$NVSHMEM_DIR")

# Files/directories that should never be deleted (safety mechanism)
DO_NOT_DELETE=(
    ".git/"
    ".gitignore"
    "nvshmem4py/cmake/addNumbast.cmake"
    "nvshmem4py/build_assets/numbast/config_nvshmem.py"
    "nvshmem4py/build_assets/numbast/numbast_entry_point.h"
    "nvshmem4py/build_assets/numbast/templates/config_nvshmem.yml.j2"
)

# Additional files to delete (generated files not in CPACK_SOURCE_IGNORE_FILES)
# This is the superset of all ALSO_DELETE definitions in the script
ALSO_DELETE=(
    "scripts/cleanup_ignore_files.sh"
    "src/include/non_abi/nvshmem_build_options.h"
    "src/include/non_abi/nvshmem_version.h"
    ".gitlab_ci_env_files/"
    "src/modules/bootstrap/uid/ncclSocket/.clang-format"
    "src/include/non_abi/device/pt-to-pt/transfer_device.cuh"
    "nvshmem4py/pyproject.toml"
    ".coderabbit.yml"
)

# Function to modify .gitignore file (shared by both branches)
modify_gitignore() {
    echo "Modifying .gitignore to remove specific lines..."
    if [ -f ".gitignore" ]; then
        # Create a backup of the original .gitignore
        cp .gitignore .gitignore.backup
        
        # Remove the specified lines from .gitignore
        sed -i '/^nvshmem4py\/nvshmem\/version\.py$/d' .gitignore
        sed -i '/^nvshmem4py\/nvshmem\/bindings\/\*\.pyx$/d' .gitignore
        sed -i '/^nvshmem4py\/nvshmem\/bindings\/\*\.pxd$/d' .gitignore
        sed -i '/^nvshmem4py\/nvshmem\/bindings\/_internal\/\*\.pyx$/d' .gitignore
        sed -i '/^nvshmem4py\/nvshmem\/bindings\/_internal\/\*\.pxd$/d' .gitignore
        
        # Remove the backup file since we don't need it
        rm -f .gitignore.backup
        git add .gitignore
        
        echo "✅ Modified .gitignore file"
    else
        echo "Warning: .gitignore file not found"
    fi
}

# Function to check if an item is in the DO_NOT_DELETE list
is_protected() {
    local item="$1"
    for protected in "${DO_NOT_DELETE[@]}"; do
        if [ "$item" = "$protected" ]; then
            return 0  # Item is protected
        fi
    done
    return 1  # Item is not protected
}

# Function to check if a directory path contains any protected items in its subtree
has_protected_subtree() {
    local dir_path="$1"
    # Normalize path (remove trailing slash for comparison)
    dir_path="${dir_path%/}"
    
    for protected in "${DO_NOT_DELETE[@]}"; do
        # Remove trailing slash from protected path for comparison
        local protected_normalized="${protected%/}"
        
        # Check if protected path starts with dir_path (is in subtree)
        if [[ "$protected_normalized" == "$dir_path"* ]] && [[ "$protected_normalized" != "$dir_path" ]]; then
            return 0  # Has protected items in subtree
        fi
    done
    return 1  # No protected items in subtree
}

# Function to recursively delete directory contents, preserving protected items
delete_directory_selective() {
    local dir_path="$1"
    local use_git="$2"
    local rel_item="$3"  # Relative path from NVSHMEM_DIR for logging
    
    # If directory doesn't exist, nothing to do
    if [ ! -d "$dir_path" ]; then
        return
    fi
    
    echo "Selectively removing directory contents: $rel_item"
    
    # Process all items in the directory (depth-first traversal)
    # Using find with -depth ensures we process files before their parent directories
    find "$dir_path" -depth -print0 2>/dev/null | while IFS= read -r -d '' item; do
        # Skip the root directory itself for now
        if [ "$item" = "$dir_path" ]; then
            continue
        fi
        
        # Get relative path from NVSHMEM_DIR for protection checking
        local rel_path="${item#$NVSHMEM_DIR/}"
        
        # Check if this item is protected (try both with and without trailing slash)
        if is_protected "$rel_path" || is_protected "$rel_path/"; then
            echo "  PROTECTED (in subtree): $rel_path"
            ((protected_count++))
            continue
        fi
        
        # Delete the item
        if [ -d "$item" ]; then
            # Try to remove directory (will only succeed if empty)
            if rmdir "$item" 2>/dev/null; then
                echo "  Removed empty directory: $rel_path"
                ((deleted_count++))
            fi
        else
            echo "  Removing file: $rel_path"
            if [ "$use_git" = "true" ]; then
                git rm -f "$item" 2>/dev/null || rm -f "$item"
            else
                rm -f "$item"
            fi
            ((deleted_count++))
        fi
    done
    
    # Finally, try to remove the root directory itself if it's now empty
    if rmdir "$dir_path" 2>/dev/null; then
        echo "  Removed directory (now empty): $rel_item"
        ((deleted_count++))
    else
        echo "  Directory not empty (contains protected items): $rel_item"
    fi
}

# Function to restore protected files from a source branch
restore_protected_files() {
    local source_branch="$1"
    
    echo "Restoring protected files from $source_branch branch..."
    
    # Check each protected item
    for protected_item in "${DO_NOT_DELETE[@]}"; do
        # Skip .git and .gitignore as they're always present
        if [ "$protected_item" = ".git/" ] || [ "$protected_item" = ".gitignore" ]; then
            continue
        fi
        
        # Remove trailing slash for path operations
        local item_path="${protected_item%/}"
        
        # Check if this file exists in the source branch
        if git cat-file -e "$source_branch:$item_path" 2>/dev/null; then
            echo "  Restoring: $item_path"
            
            # Create parent directory if needed
            local parent_dir=$(dirname "$item_path")
            if [ "$parent_dir" != "." ] && [ ! -d "$parent_dir" ]; then
                mkdir -p "$parent_dir"
            fi
            
            # Extract the file from the source branch
            git show "$source_branch:$item_path" > "$item_path"
            
            # Add to git
            git add "$item_path"
        fi
    done
    
    echo "✅ Protected files restored"
}

# Function to parse CPACK_SOURCE_IGNORE_FILES from CMakeLists.txt
parse_ignore_files() {
    local cmake_file="$NVSHMEM_DIR/src/CMakeLists.txt"
    
    if [ ! -f "$cmake_file" ]; then
        echo "Error: $cmake_file not found!"
        exit 1
    fi
    
    
    # Use a more precise approach to extract only the CPACK_SOURCE_IGNORE_FILES content
    # First, find the line with set(CPACK_SOURCE_IGNORE_FILES and extract until the closing )
    local main_content=$(awk '
        /^set\(CPACK_SOURCE_IGNORE_FILES/ {
            # Start of the block
            in_block = 1
            # Remove the opening part and get the rest of the line
            gsub(/^set\(CPACK_SOURCE_IGNORE_FILES[[:space:]]*/, "")
            # Remove trailing backslash if present
            gsub(/\\$/, "")
            line = $0
            next
        }
        in_block && /\\$/ {
            # Continuation line with backslash
            gsub(/^[[:space:]]*/, "")
            gsub(/\\$/, "")
            line = line $0
            next
        }
        in_block && !/\\$/ {
            # Last line of the block - check if it ends with )
            if (/\)$/) {
                gsub(/^[[:space:]]*/, "")
                gsub(/\)$/, "")
                line = line $0
                print line
                in_block = 0
            } else {
                gsub(/^[[:space:]]*/, "")
                line = line $0
            }
            next
        }
    ' "$cmake_file")
    
    # Extract conditional additions
    local conditional_content=$(awk '
        /^if\(NOT NVSHMEM_INSTALL_FUNCTIONAL_TESTS\)/ {
            in_conditional = 1
            next
        }
        in_conditional && /^[[:space:]]*set\(CPACK_SOURCE_IGNORE_FILES/ {
            # Extract the additional content after the variable reference
            gsub(/^[[:space:]]*set\(CPACK_SOURCE_IGNORE_FILES[[:space:]]*[^"]*"/, "")
            gsub(/\)$/, "")
            print
            in_conditional = 0
        }
        in_conditional && /^endif\(\)/ {
            in_conditional = 0
        }
    ' "$cmake_file")
    
    # Combine both parts
    local all_content="$main_content$conditional_content"

    # Parse the semicolon-separated list and convert to array
    IFS=';' read -ra FILES_TO_DELETE <<< "$all_content"

    # Clean up the paths (remove leading slash, trailing semicolon, quotes, and empty entries)
    local cleaned_files=()
    for item in "${FILES_TO_DELETE[@]}"; do
        # Remove leading slash, quotes, and trailing semicolon
        item=$(echo "$item" | sed 's|^/||' | sed 's/^"//' | sed 's/"$//' | sed 's/;$//')
        # Remove trailing $ if present (regex anchor)
        item=$(echo "$item" | sed 's/\$$//')
        # Skip empty entries
        if [ -n "$item" ]; then
            cleaned_files+=("$item")
        fi
    done

    # Return the cleaned array
    printf '%s\n' "${cleaned_files[@]}"
}

# Handle test options and exit early
if [ "$TEST_PARSE_IGNORE" = "true" ]; then
    echo "Testing parse_ignore_files function..."
    echo "NVSHMEM directory: $NVSHMEM_DIR"
    echo ""
    FILES=$(parse_ignore_files)
    echo "Parsed ignore files:"
    echo "$FILES" | nl
    echo ""
    FILE_COUNT=$(echo "$FILES" | wc -l)
    echo "Total files to delete: $FILE_COUNT"
    exit 0
fi

if [ -n "$TEST_IS_PROTECTED" ]; then
    echo "Testing is_protected function..."
    echo "File to test: $TEST_IS_PROTECTED"
    echo ""
    if is_protected "$TEST_IS_PROTECTED"; then
        echo "✅ File IS protected (in DO_NOT_DELETE list)"
        exit 0
    else
        echo "❌ File is NOT protected"
        exit 1
    fi
fi

echo "################################################################################"
echo "########################## Start Section 1: Confirmation ##########################"
echo "################################################################################"

# Validate branch name
case "$BRANCH_NAME" in
    "github_main_staging"|"github_devel_staging")
        echo "Using branch: $BRANCH_NAME"
        ;;
    *)
        echo "Error: Unsupported branch name '$BRANCH_NAME'"
        echo "Supported branches: github_main_staging, github_devel_staging"
        exit 1
        ;;
esac

# Optional: Ask for confirmation before running
if [ "$FORCE_MODE" != "true" ]; then
    echo ""
    echo "This script will delete files and directories from CPACK_SOURCE_IGNORE_FILES"
    echo "and modify git history for branch: $BRANCH_NAME"
    echo "To run without confirmation, use: $0 --force"
    echo "Press Ctrl+C to cancel, or Enter to continue..."
    read -r
fi

echo "################################################################################"
echo "########################### End Section 1: Confirmation ###########################"
echo "################################################################################"

echo "################################################################################"
echo "####################### Start Section 2: Repository Reset #######################"
echo "################################################################################"

echo "Starting cleanup of files and directories from CPACK_SOURCE_IGNORE_FILES..."
echo "NVSHMEM directory: $NVSHMEM_DIR"

# Reset to clean state to ensure proper parsing
echo "Resetting repository to clean state..."
cd "$NVSHMEM_DIR"
git reset --hard HEAD

# Clean untracked files to ensure clean checkout
echo "Cleaning untracked files..."
git clean -xfd

# Fetch latest changes from origin
echo "Fetching latest changes from origin..."
git fetch origin

# Determine upstream branch based on target branch
if [ "$BRANCH_NAME" = "github_main_staging" ]; then
    UPSTREAM_GITHUB_BRANCH="github_main_branch_tracking"
    UPSTREAM_BRANCH="main"
elif [ "$BRANCH_NAME" = "github_devel_staging" ]; then
    UPSTREAM_GITHUB_BRANCH="github_devel_branch_tracking"
    UPSTREAM_BRANCH="devel"
else
    echo "Error: Unknown branch type for upstream detection"
    exit 1
fi

# Find and checkout the upstream branch
echo "Looking for $UPSTREAM_BRANCH branch..."

# Check if local branch exists
if git show-ref --verify --quiet refs/heads/$UPSTREAM_BRANCH; then
    echo "Found local $UPSTREAM_BRANCH branch"
    echo "Switching to local $UPSTREAM_BRANCH branch..."
    git checkout $UPSTREAM_BRANCH
    if [ $? -ne 0 ]; then
        echo "Error: Failed to checkout local $UPSTREAM_BRANCH branch"
        exit 1
    fi
    echo "Resetting $UPSTREAM_BRANCH branch to upstream..."
    git reset --hard origin/$UPSTREAM_BRANCH
    if [ $? -ne 0 ]; then
        echo "Warning: Failed to reset to origin/$UPSTREAM_BRANCH, continuing with local branch"
    fi
# Check if remote branch exists
elif git show-ref --verify --quiet refs/remotes/origin/$UPSTREAM_BRANCH; then
    echo "Found remote $UPSTREAM_BRANCH branch, creating local branch..."
    git checkout -b $UPSTREAM_BRANCH origin/$UPSTREAM_BRANCH
    if [ $? -ne 0 ]; then
        echo "Error: Failed to create local $UPSTREAM_BRANCH branch from origin/$UPSTREAM_BRANCH"
        exit 1
    fi
    echo "✅ Created and switched to $UPSTREAM_BRANCH branch from origin"
else
    echo "Error: No $UPSTREAM_BRANCH branch found locally or on origin"
    exit 1
fi

# Run CMake and make to generate the source package
echo "Running CMake and make to generate source package..."

# Set CUDA environment variables if they exist
if [ -n "$CUDA_HOME" ]; then
    export CUDA_HOME
    export PATH="$CUDA_HOME/bin:$PATH"
    export LD_LIBRARY_PATH="$CUDA_HOME/lib64:$LD_LIBRARY_PATH"
    echo "Using CUDA_HOME: $CUDA_HOME"
else
    echo "Warning: CUDA_HOME not set, trying to find CUDA..."
    # Try to find CUDA in common locations
    for cuda_path in /usr/local/cuda /opt/cuda /usr/cuda; do
        if [ -d "$cuda_path" ]; then
            export CUDA_HOME="$cuda_path"
            export PATH="$CUDA_HOME/bin:$PATH"
            export LD_LIBRARY_PATH="$CUDA_HOME/lib64:$LD_LIBRARY_PATH"
            echo "Found CUDA at: $CUDA_HOME"
            break
        fi
    done
fi

docker/docker_run_wrapper.sh pack_src > cleanup_ignore_files.log 2>&1
if [ $? -ne 0 ]; then
    echo "Error: docker/docker_run_wrapper.sh pack_src failed!"
    exit 1
else
    echo "✅ docker/docker_run_wrapper.sh pack_src completed successfully"
    rm cleanup_ignore_files.log
fi

# Update the .gitignore file so we don't miss the bindings.
modify_gitignore
git add -A
git commit -m "[ADMIN] Add generated python bindings to .gitignore. $(date +%s)"

echo "################################################################################"
echo "######################## End Section 2: Repository Reset ########################"
echo "################################################################################"

echo "################################################################################"
echo "#################### Start Section 3: File Cleanup ####################"
echo "################################################################################"

# Parse the ignore files from CMakeLists.txt
FILES_TO_DELETE=($(parse_ignore_files))

echo "Found ${#FILES_TO_DELETE[@]} items in CPACK_SOURCE_IGNORE_FILES"

# Counter for tracking deletions
deleted_count=0
not_found_count=0
protected_count=0

# Function to safely delete a file or directory
delete_item() {
    local item="$1"
    local use_git="$2"
    
    # Check if item is protected
    if is_protected "$item"; then
        echo "PROTECTED: $item (in DO_NOT_DELETE list)"
        ((protected_count++))
        return
    fi
    
    # Construct the full path - always treat as relative to NVSHMEM_DIR
    if [ "$use_git" = "false" ]; then
        local full_path="$NVSHMEM_DIR/$item"
    else
        local full_path="$item"
        full_path="${full_path#/}"
    fi
    
    if [ -e "$full_path" ]; then
        if [ -d "$full_path" ]; then
            # Check if this directory has any protected items in its subtree
            if has_protected_subtree "$item"; then
                # Directory contains protected items, delete selectively
                delete_directory_selective "$full_path" "$use_git" "$item"
            else
                # No protected items, delete entire directory
                echo "Removing directory: $item"
                if [ "$use_git" = "true" ]; then
                    git rm -rf "$full_path" || true
                else
                    rm -rf "$full_path" || true
                fi
                ((deleted_count++))
            fi
        else
            echo "Removing file: $item"
            if [ "$use_git" = "true" ]; then
                git rm -f "$full_path" || true
            else
                rm -f "$full_path" || true
            fi
            ((deleted_count++))
        fi
    else
        if [ "$use_git" = "false" ]; then
            echo "Not found: $item"
            ((not_found_count++))
        fi
    fi
}

delete_commited_items() {
    TMP_FILES_TO_DELETE=($(parse_ignore_files))
    for item in "${TMP_FILES_TO_DELETE[@]}"; do
        delete_item "$item" "true"
    done

    for item in "${ALSO_DELETE[@]}"; do
        delete_item "$item" "true"
    done
}



# Process each item in the list from CPACK_SOURCE_IGNORE_FILES
for item in "${FILES_TO_DELETE[@]}"; do
    delete_item "$item" "false"
done

# Process additional files to delete
for item in "${ALSO_DELETE[@]}"; do
    delete_item "$item" "false"
done

echo ""
echo "Cleanup completed!"
echo "Items deleted: $deleted_count"
echo "Items not found: $not_found_count"
echo "Items protected: $protected_count"

echo "################################################################################"
echo "###################### End Section 3: File Cleanup ######################"
echo "################################################################################"

echo "################################################################################"
echo "####################### Start Section 4: Branch Setup #######################"
echo "################################################################################"

# Switch to new branch (delete if exists)
echo ""
echo "Switching to $BRANCH_NAME branch..."

# Check if branch exists and delete it if it does
if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
    echo "Branch $BRANCH_NAME exists, deleting it..."
    git branch -D $BRANCH_NAME
    if [ $? -ne 0 ]; then
        echo "Error: Failed to delete existing branch $BRANCH_NAME"
        exit 1
    fi
fi

# Function to cherry-pick commits with comprehensive conflict resolution
cherry_pick_commits() {
    local commits_list="$1"
    local branch_name="$2"
    local perform_cleanup="${3:-false}"  # Whether to run delete_commited_items after each commit
    
    for commit in $commits_list; do
        echo "Cherry-picking commit: $commit"
        
        # Get commit message for reference
        COMMIT_MSG=$(git log --format=%s -n 1 $commit)
        echo "  Commit message: $COMMIT_MSG"
        
        # Check if this is a merge commit (more robust detection)
        PARENT_COUNT=$(git cat-file -p $commit | grep "^parent " | wc -l)
        # Also check if git log shows it as a merge
        IS_MERGE=$(git log --format="%P" -n 1 $commit | wc -w)
        if [ "$PARENT_COUNT" -gt 1 ] || [ "$IS_MERGE" -gt 1 ]; then
            echo "  Detected merge commit $commit with $PARENT_COUNT parents"
            echo "  Attempting to cherry-pick merge commit with -m 1 (first parent)..."
            
            # For merge commits, we need to specify which parent to use
            # -m 1 means use the first parent (usually the main branch)
            GIT_EDITOR="true" git cherry-pick -m 1 $commit
            CHERRY_PICK_RESULT=$?
        else
            echo "  Regular commit detected, attempting cherry-pick..."
            # Attempt cherry-pick (non-interactive) for regular commits
            GIT_EDITOR="true" git cherry-pick $commit
            CHERRY_PICK_RESULT=$?
        fi
        
        if [ $CHERRY_PICK_RESULT -ne 0 ]; then
            echo "  Warning: Cherry-pick failed for commit $commit"
            
            # Check if this is a merge commit error (missing -m option)
            if git status 2>&1 | grep -q "is a merge but no -m option was given"; then
                echo "  This is a merge commit that requires -m option, skipping..."
                git cherry-pick --abort 2>/dev/null || true
                continue
            fi
            
            echo "  This may be due to conflicts with deleted/modified files"
            
            # Check if there are conflicts or unmerged files
            if git status --porcelain | grep -q "^UU\|^AA\|^DD\|^DU\|^UD\|^U"; then
                echo "  Conflicts detected. Attempting to resolve by favoring cherry-picked commit..."
                
                # Handle DU files (deleted by us, modified by them)
                DU_FILES=$(git status --porcelain | grep "^DU" | cut -c4-)
                if [ -n "$DU_FILES" ]; then
                    echo "  Handling DU files (deleted by us, modified by them): $DU_FILES"
                    for file in $DU_FILES; do
                        # Check if this file is protected
                        if is_protected "$file"; then
                            echo "    PROTECTED DU file: $file - keeping version from cherry-picked commit"
                            # Keep the version from the cherry-picked commit (theirs)
                            git add "$file" 2>/dev/null || true
                        else
                            echo "    Removing DU file: $file"
                            git rm "$file" 2>/dev/null || rm -f "$file"
                        fi
                    done
                fi
                
                # Handle UD files (modified by us, deleted by them)
                UD_FILES=$(git status --porcelain | grep "^UD" | cut -c4-)
                if [ -n "$UD_FILES" ]; then
                    echo "  Handling UD files (modified by us, deleted by them): $UD_FILES"
                    for file in $UD_FILES; do
                        # Check if this file is protected
                        if is_protected "$file"; then
                            echo "    PROTECTED UD file: $file - keeping current version"
                            # Keep the current version (ours) - protected files should never be deleted
                            git add "$file" 2>/dev/null || true
                        else
                            echo "    Favoring cherry-picked commit deletion of UD file: $file"
                            git rm "$file" 2>/dev/null || rm -f "$file"
                        fi
                    done
                fi
                
                # Handle AU files (added by us, unmerged) - these should be kept
                AU_FILES=$(git status --porcelain | grep "^AU" | cut -c4-)
                if [ -n "$AU_FILES" ]; then
                    echo "  Handling AU files (added by us, unmerged): $AU_FILES"
                    for file in $AU_FILES; do
                        echo "    Keeping AU file: $file"
                        git add "$file" 2>/dev/null || true
                    done
                fi
                
                # Handle UA files (unmerged, added by them)
                UA_FILES=$(git status --porcelain | grep "^UA" | cut -c4-)
                if [ -n "$UA_FILES" ]; then
                    echo "  Handling UA files (unmerged, added by them): $UA_FILES"
                    for file in $UA_FILES; do
                        # Check if this file is protected
                        if is_protected "$file"; then
                            echo "    PROTECTED UA file: $file - keeping version from cherry-picked commit"
                            # Keep the version from the cherry-picked commit (theirs)
                            git add "$file" 2>/dev/null || true
                        else
                            echo "    Removing UA file: $file"
                            git rm "$file" 2>/dev/null || rm -f "$file"
                        fi
                    done
                fi
                
                # Handle UU/AA/DD files (conflicted files) - favor cherry-picked commit version
                CONFLICTED_FILES=$(git status --porcelain | grep "^UU\|^AA\|^DD" | cut -c4-)
                if [ -n "$CONFLICTED_FILES" ]; then
                    echo "  Handling conflicted files: $CONFLICTED_FILES"
                    for file in $CONFLICTED_FILES; do
                        # Check if this file is in our deletion list
                        if echo "${FILES_TO_DELETE[@]}" | grep -q "\b$file\b" || echo "${ALSO_DELETE[@]}" | grep -q "\b$file\b"; then
                            echo "    File $file should be deleted, removing it..."
                            git rm "$file" 2>/dev/null || rm -f "$file"
                        else
                            echo "    File $file should be kept, favoring cherry-picked commit version..."
                            # Get the version from the cherry-picked commit (theirs)
                            if git checkout --theirs "$file" 2>/dev/null; then
                                echo "      Successfully restored cherry-picked version of $file"
                                git add "$file" 2>/dev/null || true
                            elif git show $commit:"$file" > "$file" 2>/dev/null; then
                                echo "      Successfully extracted cherry-picked version of $file from commit"
                                git add "$file" 2>/dev/null || true
                            else
                                echo "      Warning: Could not restore cherry-picked version of $file, keeping current"
                            fi
                        fi
                    done
                fi
                
                # Handle any remaining unmerged files (U status)
                UNMERGED_FILES=$(git status --porcelain | grep "^U " | cut -c4-)
                if [ -n "$UNMERGED_FILES" ]; then
                    echo "  Handling remaining unmerged files: $UNMERGED_FILES"
                    for file in $UNMERGED_FILES; do
                        # Always keep protected files
                        if is_protected "$file"; then
                            echo "    PROTECTED unmerged file: $file - keeping version from cherry-picked commit"
                            # Get the version from the cherry-picked commit (theirs)
                            if git checkout --theirs "$file" 2>/dev/null; then
                                echo "      Successfully restored cherry-picked version of $file"
                                git add "$file" 2>/dev/null || true
                            elif git show $commit:"$file" > "$file" 2>/dev/null; then
                                echo "      Successfully extracted cherry-picked version of $file from commit"
                                git add "$file" 2>/dev/null || true
                            else
                                echo "      Warning: Could not restore cherry-picked version of $file, keeping current"
                            fi
                        elif echo "${FILES_TO_DELETE[@]}" | grep -q "\b$file\b" || echo "${ALSO_DELETE[@]}" | grep -q "\b$file\b"; then
                            echo "    Removing unmerged file: $file"
                            git rm "$file" 2>/dev/null || rm -f "$file"
                        else
                            echo "    Adding unmerged file: $file"
                            # Get the version from the cherry-picked commit (theirs)
                            if git checkout --theirs "$file" 2>/dev/null; then
                                echo "      Successfully restored cherry-picked version of $file"
                                git add "$file" 2>/dev/null || true
                            elif git show $commit:"$file" > "$file" 2>/dev/null; then
                                echo "      Successfully extracted cherry-picked version of $file from commit"
                                git add "$file" 2>/dev/null || true
                            else
                                echo "      Warning: Could not restore cherry-picked version of $file, keeping current"
                            fi
                        fi
                    done
                fi
                
                # Handle any remaining deleted files that need to be staged
                DELETED_FILES=$(git status --porcelain | grep "^D " | cut -c4-)
                if [ -n "$DELETED_FILES" ]; then
                    echo "  Staging deleted files: $DELETED_FILES"
                    for file in $DELETED_FILES; do
                        # Never stage deletion of protected files - restore them instead
                        if is_protected "$file"; then
                            echo "    PROTECTED deleted file: $file - attempting to restore"
                            # Try to restore from the cherry-picked commit
                            if git show $commit:"$file" > "$file" 2>/dev/null; then
                                echo "      Successfully restored from commit"
                                git add "$file" 2>/dev/null || true
                            else
                                echo "      Warning: Could not restore $file from commit"
                            fi
                        else
                            echo "    Staging deletion of: $file"
                            git add "$file" 2>/dev/null || true
                        fi
                    done
                fi
                
                # Update the file deletion lists for conflict resolution if requested
                if [ "$perform_cleanup" = "true" ]; then
                    echo "  Removing unwanted, but merged files in current commit..."
                    delete_commited_items
                    git add -A
                fi
                
                # Complete the cherry-pick (non-interactive)
                GIT_EDITOR="true" git cherry-pick --continue
                
                # Debug: Check for untracked files after cherry-pick --continue
                echo "  Debug: Checking git status after cherry-pick --continue..."
                if ! git diff --quiet || ! git diff --cached --quiet; then
                    echo "  WARNING: Untracked changes detected after cherry-pick --continue:"
                    git status --porcelain
                    echo "  Staged changes:"
                    git diff --cached --name-only
                    echo "  Unstaged changes:"
                    git diff --name-only
                else
                    echo "  No untracked changes detected"
                fi
                
                if [ $? -ne 0 ]; then
                    echo "  Error: Failed to resolve conflicts for commit $commit"
                    echo "  Aborting cherry-pick and skipping commit $commit"
                    git cherry-pick --abort
                    continue
                else
                    echo "  Successfully resolved conflicts for commit $commit"
                fi
            else
                echo "  Cherry-pick failed for other reasons, skipping commit $commit"
                # Abort the cherry-pick to clean up the state
                git cherry-pick --abort
                continue
            fi
        else
            echo "  Successfully cherry-picked commit $commit"
        fi
        
        # Post-commit cleanup if requested
        if [ "$perform_cleanup" = "true" ]; then
            echo "  Removing unwanted, but merged files in current commit..."
            delete_commited_items
            git add -A
            git commit --amend --no-edit
        fi
    done
}

# Function to handle branch-specific modifications
handle_branch_specific_modifications() {
    local branch_type="$1"

    #done after build and cleanup to make sure we have the latest build artifacts, but nothing we don't want.
    echo "Committing all changes to $UPSTREAM_BRANCH branch..."
    git add -A
    git commit --amend --no-edit

    git checkout $UPSTREAM_GITHUB_BRANCH
    git reset --hard origin/$UPSTREAM_GITHUB_BRANCH
    
    case "$branch_type" in
        # Add any specific modifications for main staging branch here
         "github_main_staging")
             echo "################################################################################"
             echo "################## Start Section 5: Git History Modification ##################"
             echo "################################################################################"

             echo "Applying modifications for main staging branch..."
             
             # We're now on the target branch, but we need to work with the upstream branch
             echo "Working with upstream branch: $UPSTREAM_GITHUB_BRANCH"

            # Create the new $BRANCH_NAME branch based on $UPSTREAM_GITHUB_BRANCH             
            # Delete branch if it already exists, then create the new branch
            if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
                echo "Branch $BRANCH_NAME exists, deleting it..."
                git branch -D $BRANCH_NAME
            fi
            
            git checkout -b $BRANCH_NAME
            if [ $? -ne 0 ]; then
                echo "Error: Failed to create $BRANCH_NAME branch"
                exit 1
            fi
             
             # Function to parse version from CMakeLists.txt
             parse_version() {
                 local cmake_file="$NVSHMEM_DIR/CMakeLists.txt"
                 
                 if [ ! -f "$cmake_file" ]; then
                     echo "Error: $cmake_file not found!"
                     exit 1
                 fi
                 
                 # Find lines containing "VERSION" and extract version numbers
                 local version_lines=$(grep -n "VERSION" "$cmake_file" | grep -E "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+")
                 local line_count=$(echo "$version_lines" | wc -l)
                 
                 if [ "$line_count" -eq 0 ]; then
                     echo "Error: No VERSION line found in $cmake_file"
                     exit 1
                 elif [ "$line_count" -gt 1 ]; then
                     echo "Error: Multiple VERSION lines found in $cmake_file:"
                     echo "$version_lines"
                     exit 1
                 fi
                 
                 # Extract version numbers (w.x.y.z format)
                 local version=$(echo "$version_lines" | sed -n 's/.*VERSION[[:space:]]*\([0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p')
                 
                 if [ -z "$version" ]; then
                     echo "Error: Could not parse version from line: $version_lines"
                     exit 1
                 fi
                 
                 echo "Found version: $version" >&2
                 echo "$version"
             }

             # Step 1: Parse version from $UPSTREAM_GITHUB_BRANCH (current branch)
             echo "Step 1: Parsing version from $UPSTREAM_GITHUB_BRANCH..."
             VERSION_TRACKING=$(parse_version)
             if [ $? -ne 0 ]; then
                 echo "Failed to parse version from $UPSTREAM_GITHUB_BRANCH"
                 exit 1
             fi
             
             # Convert version format from w.x.y.z to w.x.y-z for tag matching
             VERSION_TAG=$(echo "$VERSION_TRACKING" | sed 's/\.\([0-9]\+\)$/-\1/')
             echo "Looking for tag: $VERSION_TAG"
             
             # Step 2: Find the matching tag on main branch
             echo "Step 2: Looking for tag $VERSION_TAG on $UPSTREAM_BRANCH branch..."
             
             # Check if the tag exists
             if ! git rev-parse "$VERSION_TAG" >/dev/null 2>&1; then
                 echo "Error: Tag $VERSION_TAG not found in repository"
                 echo "Available tags matching pattern:"
                 git tag -l "v*" | grep -E "v[0-9]+\.[0-9]+\.[0-9]+-[0-9]+" | tail -10
                 exit 1
             fi
             
             TAG_COMMIT=$(git rev-parse "$VERSION_TAG")
             echo "✅ Found tag $VERSION_TAG at commit: $TAG_COMMIT"
             
             # Step 3: Get commits between the tag and HEAD of main branch
             echo "Step 3: Finding commits between tag $VERSION_TAG and HEAD of $UPSTREAM_BRANCH..."
             
             # Get the list of commits from the tag to HEAD of main
             COMMITS_TO_APPLY=$(git rev-list "$VERSION_TAG"..$UPSTREAM_BRANCH --reverse)
             COMMIT_COUNT=$(echo "$COMMITS_TO_APPLY" | grep -c "^" || echo "0")


             
             if [ "$COMMIT_COUNT" -eq 0 ] || [ -z "$COMMITS_TO_APPLY" ]; then
                 echo "No commits found between tag $VERSION_TAG and HEAD of $UPSTREAM_BRANCH"
                 echo "The tag is up to date with $UPSTREAM_BRANCH HEAD"
             else
                 echo "✅ Found $COMMIT_COUNT commit(s) to apply from $UPSTREAM_BRANCH"
                 
                 # Step 4: Cherry-pick commits from main onto github_main_branch_tracking
                 echo "Step 4: Applying commits from $UPSTREAM_BRANCH to current branch..."
                 cherry_pick_commits "$COMMITS_TO_APPLY" "$UPSTREAM_BRANCH" "true"
                 echo "✅ Finished applying commits from $UPSTREAM_BRANCH"
             fi
             
             # Step 5: Create branch with all commits from UPSTREAM_GITHUB_BRANCH + squashed new changes
             echo "Step 5: Creating $BRANCH_NAME with all commits from $UPSTREAM_GITHUB_BRANCH + squashed new changes..."
             
             # Get the current state (with all cherry-picked commits and modifications)
             # We need to squash everything after $UPSTREAM_GITHUB_BRANCH into one commit
             
             # Count how many commits were added after the original $UPSTREAM_GITHUB_BRANCH
             COMMITS_AFTER=$(git rev-list $UPSTREAM_GITHUB_BRANCH..HEAD --count)
             echo "Found $COMMITS_AFTER commit(s) to squash on top of $UPSTREAM_GITHUB_BRANCH"
             
             if [ "$COMMITS_AFTER" -gt 0 ]; then
                 # Parse version from main branch for squash commit message
                 git checkout $UPSTREAM_BRANCH
                 VERSION_MAIN=$(parse_version)
                 git checkout $BRANCH_NAME
                 
                 if [ $? -ne 0 ]; then
                     echo "Failed to parse version from $UPSTREAM_BRANCH"
                     exit 1
                 fi

                 # Convert version format from w.x.y.z to w.x.y-z
                 VERSION_COMMIT=$(echo "$VERSION_MAIN" | sed 's/\.\([0-9]\+\)$/-\1/')
                 VERSION_SQUASH="Version: $VERSION_COMMIT"

                 echo "Squash commit message: $VERSION_SQUASH"
                 
                 # Soft reset to $UPSTREAM_GITHUB_BRANCH to keep all changes staged
                 git reset --soft $UPSTREAM_GITHUB_BRANCH
                 
                 # Remove the cleanup script from staging
                 git rm --cached scripts/cleanup_ignore_files.sh 2>/dev/null || true

                # Create the squashed commit with all changes
                git commit -m "$VERSION_SQUASH"
                if [ $? -ne 0 ]; then
                    echo "Error: Failed to create squashed commit"
                    exit 1
                fi
             else
                 echo "No new commits to squash, using $UPSTREAM_GITHUB_BRANCH as-is"
             fi
            
            # Restore protected files from the main branch
            echo "Restoring protected files to $BRANCH_NAME..."
            restore_protected_files "$UPSTREAM_BRANCH"
            
            # Commit the restored protected files
            if ! git diff --quiet || ! git diff --cached --quiet; then
                echo "Committing restored protected files..."
                git commit --amend --no-edit
            fi

            echo "✅ Successfully created $BRANCH_NAME with all commits from $UPSTREAM_GITHUB_BRANCH + squashed changes"
            echo "✅ Git history modification completed!"
            
            echo "################################################################################"
            echo "################## End Section 5: Git History Modification ##################"
            echo "################################################################################"
            ;;

         # Add any specific modifications for devel branch here
         "github_devel_staging")
             echo "################################################################################"
             echo "################## Start Section 5: Git History Modification ##################"
             echo "################################################################################"

             echo "Applying modifications for development staging branch..."
             
             # We're now on the target branch, but we need to work with the upstream branch
             echo "Working with branch: $UPSTREAM_GITHUB_BRANCH"
             
             # Find commits that differ between main and devel branches
             echo "Finding commits that differ between $UPSTREAM_GITHUB_BRANCH and $UPSTREAM_BRANCH branches..."
             
             # Try to find merge-base first
             MERGE_BASE=$(git merge-base $UPSTREAM_GITHUB_BRANCH $UPSTREAM_BRANCH 2>/dev/null || true)
             
             if [ -z "$MERGE_BASE" ]; then
                 echo "No common commit ID found, searching for matching commit messages..."
                 
                 echo "Building index of commit messages from $UPSTREAM_BRANCH..."
                 git log --format=%s $UPSTREAM_BRANCH > ${UPSTREAM_BRANCH}_messages.txt

                 echo "Searching for matching commit messages..."
                 git log --format=%s $UPSTREAM_GITHUB_BRANCH > ${UPSTREAM_GITHUB_BRANCH}_messages.txt

                 SYNC_COMMIT_MSG=$(grep -x -F -f ${UPSTREAM_BRANCH}_messages.txt ${UPSTREAM_GITHUB_BRANCH}_messages.txt | head -n1)
                 SYNC_COMMIT=$(git log --grep="$SYNC_COMMIT_MSG" --format=%H -n 1 $UPSTREAM_BRANCH)
                 echo "First matching commit: $SYNC_COMMIT with message: $SYNC_COMMIT_MSG"
                 rm ${UPSTREAM_BRANCH}_messages.txt
                 rm ${UPSTREAM_GITHUB_BRANCH}_messages.txt
                 
                 if [ -z "$SYNC_COMMIT" ]; then
                     echo "Error: Could not find any matching commit messages between branches"
                     exit 1
                 fi
                 
                 # Get commits in devel after the sync point
                 COMMITS_TO_PRESERVE=$(git rev-list $SYNC_COMMIT..$UPSTREAM_BRANCH --reverse)
             else
                 echo "Found common ancestor: $MERGE_BASE"
                 # Find commits in devel from the merge-base to HEAD
                 COMMITS_TO_PRESERVE=$(git rev-list $MERGE_BASE..$UPSTREAM_BRANCH --reverse)
             fi
             COMMIT_COUNT=$(echo "$COMMITS_TO_PRESERVE" | wc -l)
             echo "Found $COMMIT_COUNT commits in $UPSTREAM_BRANCH that are not in $UPSTREAM_GITHUB_BRANCH"

             if [ "$COMMIT_COUNT" -eq 0 ]; then
                 echo "No commits found in $UPSTREAM_BRANCH that differ from $UPSTREAM_GITHUB_BRANCH, $UPSTREAM_BRANCH branch is identical to $UPSTREAM_GITHUB_BRANCH"
             fi
             
            # Create the new $BRANCH_NAME branch based on $UPSTREAM_GITHUB_BRANCH             
            # Delete branch if it already exists, then create the new branch
            if git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
                echo "Branch $BRANCH_NAME exists, deleting it..."
                git branch -D $BRANCH_NAME
            fi
            
            git checkout -b $BRANCH_NAME
            if [ $? -ne 0 ]; then
                echo "Error: Failed to create $BRANCH_NAME branch"
                exit 1
            fi
             
             # Cherry-pick commits from $UPSTREAM_BRANCH branch
             if [ "$COMMIT_COUNT" -gt 0 ]; then
                 echo "Cherry-picking $COMMIT_COUNT commits from $UPSTREAM_BRANCH branch..."
                 cherry_pick_commits "$COMMITS_TO_PRESERVE" "$UPSTREAM_BRANCH" "true"
                 echo "✅ Completed cherry-picking $UPSTREAM_BRANCH commits"
             fi
            
            # Restore protected files from the devel branch
            echo "Restoring protected files to $BRANCH_NAME..."
            restore_protected_files "$UPSTREAM_BRANCH"
            
            # Commit the restored protected files
            if ! git diff --quiet || ! git diff --cached --quiet; then
                echo "Committing restored protected files..."
                git commit -m "Restore protected files"
            fi
             
             echo "✅ Successfully created github_devel_staging with preserved commit history"
             echo "✅ Git history modification completed!"
             
             echo "################################################################################"
             echo "################## End Section 5: Git History Modification ##################"
             echo "################################################################################"
             ;;
        *)
            echo "Warning: Unknown branch type '$branch_type', using default modifications"
            ;;
    esac
}

# Apply branch-specific modifications and create orphan branch
handle_branch_specific_modifications "$BRANCH_NAME"

echo "################################################################################"
echo "######################## End Section 4: Branch Setup ########################"
echo "################################################################################"

echo "################################################################################"
echo "####################### Start Section 6: Sanity Check #######################"
echo "################################################################################"

# Sanity check: Compare the created branch with upstream branch excluding deleted files
echo "Performing sanity check to verify branch equivalence..."

# Perform the diff comparison excluding deleted files, .gitignore changes, and generated files
git clean -xfd

echo "Comparing $BRANCH_NAME with $UPSTREAM_BRANCH (excluding deleted files, .gitignore changes, and generated files)..."
DIFF_OUTPUT=$(git diff --name-only --diff-filter=ACMRTUX $UPSTREAM_BRANCH $BRANCH_NAME | grep -v "^\.gitignore$" | grep -v "^\.gitattributes$" | grep -v "^nvshmem4py/nvshmem/bindings/" | grep -v "^nvshmem4py/nvshmem/core/device/numba/" | grep -v "^nvshmem4py/nvshmem/version\.py$" | grep -v "^nvshmem4py/pyproject\.toml$" | grep -v "^nvshmem4py/requirements_.*\.txt$" | grep -v "^nvshmem4py/scripts/generate_pyproject_toml\.py$" | grep -v "^nvshmem4py/cmake/buildWheel\.cmake$" | grep -v ".github/" || true)

if [ -z "$DIFF_OUTPUT" ]; then
    echo "✅ SANITY CHECK PASSED: Branches are equivalent (excluding deleted files, .gitignore, and generated files)"
    echo "✅ The $BRANCH_NAME branch contains the same content as $UPSTREAM_BRANCH"
    echo "✅ All intended files have been successfully removed"
else
    echo "❌ SANITY CHECK FAILED: Branches are not equivalent"
    echo "❌ The following files differ between $UPSTREAM_BRANCH and $BRANCH_NAME:"
    echo "$DIFF_OUTPUT"
    echo ""
    echo "This indicates that some files were not properly cleaned up or there are unexpected differences."
    echo "Please review the cleanup process and try again."
    exit 1
fi

echo "################################################################################"
echo "######################## End Section 6: Sanity Check ########################"
echo "################################################################################"

echo "################################################################################"
echo "####################### Start Section 7: Sanity Build #######################"
echo "################################################################################"

cmake -S $NVSHMEM_DIR -B $NVSHMEM_DIR/build -DNVSHMEM_DEBUG=ON -DNVSHMEM_BUILD_PYTHON_LIB=ON -DNVSHMEM_BUILD_CLANG_LIBRARY=OFF
if [ $? -ne 0 ]; then
    echo "Error: Failed to run CMake"
    exit 1
fi
make -C $NVSHMEM_DIR/build -j16 install
if [ $? -ne 0 ]; then
    echo "Error: Failed to run make install"
    exit 1
fi

rm nvshmem4py/nvshmem/bindings/numba/_numbast.py

cmake -S $NVSHMEM_DIR -B $NVSHMEM_DIR/build -DNVSHMEM_DEBUG=ON -DNVSHMEM_BUILD_PYTHON_LIB=ON -DNVSHMEM_BUILD_CLANG_LIBRARY=OFF
make -C $NVSHMEM_DIR/build -j16 install
if [ $? -ne 0 ]; then
    echo "Error: Failed to run make install with numba bindings"
    exit 1
fi

git clean -xfd

echo "################################################################################"
echo "####################### End Section 7: Sanity Build #######################"
echo "################################################################################"
